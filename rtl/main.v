`timescale	1ps / 1ps
////////////////////////////////////////////////////////////////////////////////
//
// Filename:	./main.v
//
// Project:	OpenZ7, an open source Zynq demo based on the Arty Z7-20
//
// DO NOT EDIT THIS FILE!
// Computer Generated: This file is computer generated by AUTOFPGA. DO NOT EDIT.
// DO NOT EDIT THIS FILE!
//
// CmdLine:	autofpga autofpga -d -o . global.txt axilboard.txt controlbus.txt zynqps.txt
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2020, Gisselquist Technology, LLC
//
// This program is free software (firmware): you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or (at
// your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no
// target there if the PDF file isn't present.)  If not, see
// <http://www.gnu.org/licenses/> for a copy.
//
// License:	GPL, v3, as defined and found on www.gnu.org,
//		http://www.gnu.org/licenses/gpl.html
//
//
////////////////////////////////////////////////////////////////////////////////
//
//
`default_nettype	none
//
//
// Here is a list of defines which may be used, post auto-design
// (not post-build), to turn particular peripherals (and bus masters)
// on and off.  In particular, to turn off support for a particular
// design component, just comment out its respective `define below.
//
// These lines are taken from the respective @ACCESS tags for each of our
// components.  If a component doesn't have an @ACCESS tag, it will not
// be listed here.
//
// First, the independent access fields for any bus masters
// And then for the independent peripherals
//
// End of dependency list
//
//
//
// Any include files
//
// These are drawn from anything with a MAIN.INCLUDE definition.
//
//
// Finally, we define our main module itself.  We start with the list of
// I/O ports, or wires, passed into (or out of) the main function.
//
// These fields are copied verbatim from the respective I/O port lists,
// from the fields given by @MAIN.PORTLIST
//
module	main(i_clk, i_reset,
		// i_GP0_ACLK,
		i_GP0_AWVALID,
		o_GP0_AWREADY,
		i_GP0_AWID,
		i_GP0_AWADDR,
		i_GP0_AWLEN,
		i_GP0_AWSIZE,
		i_GP0_AWBURST,
		i_GP0_AWLOCK,
		i_GP0_AWCACHE,
		i_GP0_AWPROT,
		i_GP0_AWQOS,
		//
		i_GP0_WVALID,
		o_GP0_WREADY,
		// M_AXI_GP0_WID,
		i_GP0_WDATA,
		i_GP0_WSTRB,
		i_GP0_WLAST,
		//
		o_GP0_BVALID,
		i_GP0_BREADY,
		o_GP0_BID,
		o_GP0_BRESP,
		//
		i_GP0_ARVALID,
		o_GP0_ARREADY,
		i_GP0_ARID,
		i_GP0_ARADDR,
		i_GP0_ARLEN,
		i_GP0_ARSIZE,
		i_GP0_ARBURST,
		i_GP0_ARLOCK,
		i_GP0_ARCACHE,
		i_GP0_ARPROT,
		i_GP0_ARQOS,
		//
		o_GP0_RVALID,
		i_GP0_RREADY,
		o_GP0_RID,
		o_GP0_RDATA,
		o_GP0_RLAST,
		o_GP0_RRESP,
		// S_AXI_HP0_ACLK,
		o_HP0_AWVALID,
		i_HP0_AWREADY,
		o_HP0_AWID,
		o_HP0_AWADDR,
		o_HP0_AWLEN,
		o_HP0_AWSIZE,
		o_HP0_AWBURST,
		o_HP0_AWLOCK,
		o_HP0_AWCACHE,
		o_HP0_AWPROT,
		o_HP0_AWQOS,
		//
		o_HP0_WVALID,
		i_HP0_WREADY,
		// o_HP0_WID,
		o_HP0_WDATA,
		o_HP0_WSTRB,
		o_HP0_WLAST,
		//
		i_HP0_BVALID,
		o_HP0_BREADY,
		i_HP0_BID,
		i_HP0_BRESP,
		//
		o_HP0_ARVALID,
		i_HP0_ARREADY,
		o_HP0_ARID,
		o_HP0_ARADDR,
		o_HP0_ARLEN,
		o_HP0_ARSIZE,
		o_HP0_ARBURST,
		o_HP0_ARLOCK,
		o_HP0_ARCACHE,
		o_HP0_ARPROT,
		o_HP0_ARQOS,
		//
		i_HP0_RVALID,
		o_HP0_RREADY,
		i_HP0_RID,
		i_HP0_RDATA,
		i_HP0_RLAST,
		i_HP0_RRESP,
		//
		o_HP0_WRISSUECAP1_EN,
		o_HP0_RDISSUECAP1_EN,
		i_HP0_WACOUNT,
		i_HP0_WCOUNT,
		i_HP0_RACOUNT,
		i_HP0_RCOUNT,
		i_sw, i_btn, o_led,
		o_redled, o_grnled, o_bluled);
//
// Any parameter definitions
//
// These are drawn from anything with a MAIN.PARAM definition.
// As they aren't connected to the toplevel at all, it would
// be best to use localparam over parameter, but here we don't
// check
//
// The next step is to declare all of the various ports that were just
// listed above.  
//
// The following declarations are taken from the values of the various
// @MAIN.IODECL keys.
//
	input	wire		i_clk;
	// verilator lint_off UNUSED
	input	wire		i_reset;
	// verilator lint_on UNUSED
	//
	// GP0 32-bit AXI4 wire definitions
	input	wire		i_GP0_AWVALID;
	output	wire		o_GP0_AWREADY;
	input	wire	[11:0]	i_GP0_AWID;
	// Verilator lint_off UNUSED
	input	wire	[31:0]	i_GP0_AWADDR;
	// Verilator lint_on  UNUSED
	input	wire	[7:0]	i_GP0_AWLEN;
	input	wire	[2:0]	i_GP0_AWSIZE;
	input	wire	[1:0]	i_GP0_AWBURST;
	input	wire		i_GP0_AWLOCK;
	input	wire	[3:0]	i_GP0_AWCACHE;
	input	wire	[2:0]	i_GP0_AWPROT;
	input	wire	[3:0]	i_GP0_AWQOS;
		//
	input	wire		i_GP0_WVALID;
	output	wire		o_GP0_WREADY;
	// [11:0]	gp0_axi4_WID;
	input	wire	[31:0]	i_GP0_WDATA;
	input	wire	[3:0]	i_GP0_WSTRB;
	input	wire		i_GP0_WLAST;
		//
	output	wire		o_GP0_BVALID;
	input	wire		i_GP0_BREADY;
	output	wire	[11:0]	o_GP0_BID;
	output	wire	 [1:0]	o_GP0_BRESP;
		//
	input	wire		i_GP0_ARVALID;
	output	wire		o_GP0_ARREADY;
	input	wire	[11:0]	i_GP0_ARID;
	// Verilator lint_off UNUSED
	input	wire	[31:0]	i_GP0_ARADDR;
	// Verilator lint_on  UNUSED
	input	wire	[7:0]	i_GP0_ARLEN;
	input	wire	[2:0]	i_GP0_ARSIZE;
	input	wire	[1:0]	i_GP0_ARBURST;
	input	wire		i_GP0_ARLOCK;
	input	wire	[3:0]	i_GP0_ARCACHE;
	input	wire	[2:0]	i_GP0_ARPROT;
	input	wire	[3:0]	i_GP0_ARQOS;
		//
	output	wire		o_GP0_RVALID;
	input	wire		i_GP0_RREADY;
	output	wire [11:0]	o_GP0_RID;
	output	wire [31:0]	o_GP0_RDATA;
	output	wire		o_GP0_RLAST;
	output	wire	[1:0]	o_GP0_RRESP;
	output	wire		o_HP0_AWVALID;
	input	wire		i_HP0_AWREADY;
	output	wire	[5:0]	o_HP0_AWID;
	output	wire	[31:0]	o_HP0_AWADDR;
	output	wire	[7:0]	o_HP0_AWLEN;
	output	wire	[2:0]	o_HP0_AWSIZE;
	output	wire	[1:0]	o_HP0_AWBURST;
	output	wire		o_HP0_AWLOCK;
	output	wire	[3:0]	o_HP0_AWCACHE;
	output	wire	[2:0]	o_HP0_AWPROT;
	output	wire	[3:0]	o_HP0_AWQOS;
		//
	output	wire		o_HP0_WVALID;
	input	wire		i_HP0_WREADY;
	// output	wire	[7:0]	o_HP0_WID;
	output	wire	[63:0]	o_HP0_WDATA;
	output	wire	[7:0]	o_HP0_WSTRB;
	output	wire		o_HP0_WLAST;
		//
	input	wire		i_HP0_BVALID;
	output	wire		o_HP0_BREADY;
	input	wire	[5:0]	i_HP0_BID;
	input	wire	[1:0]	i_HP0_BRESP;
		//
	output	wire		o_HP0_ARVALID;
	input	wire		i_HP0_ARREADY;
	output	wire	[5:0]	o_HP0_ARID;
	output	wire	[31:0]	o_HP0_ARADDR;
	output	wire	[7:0]	o_HP0_ARLEN;
	output	wire	[2:0]	o_HP0_ARSIZE;
	output	wire	[1:0]	o_HP0_ARBURST;
	output	wire		o_HP0_ARLOCK;
	output	wire	[3:0]	o_HP0_ARCACHE;
	output	wire	[2:0]	o_HP0_ARPROT;
	output	wire	[3:0]	o_HP0_ARQOS;
		//
	// Verilator lint_off UNUSED
	input	wire		i_HP0_RVALID;
	output	wire		o_HP0_RREADY;
	input	wire	[5:0]	i_HP0_RID;
	input	wire	[63:0]	i_HP0_RDATA;
	input	wire		i_HP0_RLAST;
	input	wire	[1:0]	i_HP0_RRESP;
	// Verilator lint_on  UNUSED
		//
	// Verilator lint_off UNUSED
	output	wire		o_HP0_WRISSUECAP1_EN,
				o_HP0_RDISSUECAP1_EN;
	input	wire	[5:0]	i_HP0_WACOUNT;
	input	wire	[7:0]	i_HP0_WCOUNT;
	input	wire	[2:0]	i_HP0_RACOUNT;
	input	wire	[7:0]	i_HP0_RCOUNT;
	// Verilator lint_on  UNUSED
		//
	input	wire	[1:0]	i_sw;
	input	wire	[3:0]	i_btn;
	output	wire	[3:0]	o_led;
	output	wire	[1:0]	o_redled;
	output	wire	[1:0]	o_grnled;
	output	wire	[1:0]	o_bluled;
	// Make Verilator happy ... defining bus wires for lots of components
	// often ends up with unused wires lying around.  We'll turn off
	// Ver1lator's lint warning here that checks for unused wires.
	// verilator lint_off UNUSED



	//
	// Declaring interrupt lines
	//
	// These declarations come from the various components values
	// given under the @INT.<interrupt name>.WIRE key.
	//


	//
	// Component declarations
	//
	// These declarations come from the @MAIN.DEFNS keys found in the
	// various components comprising the design.
	//


	//
	// Declaring interrupt vector wires
	//
	// These declarations come from the various components having
	// PIC and PIC.MAX keys.
	//
	//
	//
	// Define bus wires
	//
	//

	// Bus axi
	//	// AXI4 slave definitions for bus axi,
	// slave gp0, with prefix axi_gp0
	//
	wire		axi_gp0_awvalid;
	wire		axi_gp0_awready;
	wire	[11:0]	axi_gp0_awid;
	wire	[4:0]	axi_gp0_awaddr;
	wire	[7:0]	axi_gp0_awlen;
	wire	[2:0]	axi_gp0_awsize;
	wire	[1:0]	axi_gp0_awburst;
	wire		axi_gp0_awlock;
	wire	[3:0]	axi_gp0_awcache;
	wire	[2:0]	axi_gp0_awprot;
	wire	[3:0]	axi_gp0_awqos;
	//
	wire		axi_gp0_wvalid;
	wire		axi_gp0_wready;
	wire	[31:0]	axi_gp0_wdata;

	wire	[3:0]	axi_gp0_wstrb;

	wire		axi_gp0_wlast;

	wire		axi_gp0_bvalid;
	wire		axi_gp0_bready;
	wire	[11:0]	axi_gp0_bid;
	wire	[1:0]	axi_gp0_bresp;
	wire		axi_gp0_arvalid;
	wire		axi_gp0_arready;
	wire	[11:0]	axi_gp0_arid;
	wire	[4:0]	axi_gp0_araddr;
	wire	[7:0]	axi_gp0_arlen;
	wire	[2:0]	axi_gp0_arsize;
	wire	[1:0]	axi_gp0_arburst;
	wire		axi_gp0_arlock;
	wire	[3:0]	axi_gp0_arcache;
	wire	[2:0]	axi_gp0_arprot;
	wire	[3:0]	axi_gp0_arqos;
	//
	wire		axi_gp0_rvalid;
	wire		axi_gp0_rready;
	wire	[11:0]	axi_gp0_rid;
	wire	[31:0]	axi_gp0_rdata;

	wire		axi_gp0_rlast;

	wire	[1:0]	axi_gp0_rresp;

	// Bus axi has no SINGLE slaves
	//

	// Bus axi has no DOUBLE slaves
	//
	//	// AXI4 slave definitions for bus axi,
	// slave controlbus, with prefix axi_controlbus
	//
	wire		axi_controlbus_awvalid;
	wire		axi_controlbus_awready;
	wire	[11:0]	axi_controlbus_awid;
	wire	[4:0]	axi_controlbus_awaddr;
	wire	[7:0]	axi_controlbus_awlen;
	wire	[2:0]	axi_controlbus_awsize;
	wire	[1:0]	axi_controlbus_awburst;
	wire		axi_controlbus_awlock;
	wire	[3:0]	axi_controlbus_awcache;
	wire	[2:0]	axi_controlbus_awprot;
	wire	[3:0]	axi_controlbus_awqos;
	//
	wire		axi_controlbus_wvalid;
	wire		axi_controlbus_wready;
	wire	[31:0]	axi_controlbus_wdata;

	wire	[3:0]	axi_controlbus_wstrb;

	wire		axi_controlbus_wlast;

	wire		axi_controlbus_bvalid;
	wire		axi_controlbus_bready;
	wire	[11:0]	axi_controlbus_bid;
	wire	[1:0]	axi_controlbus_bresp;
	wire		axi_controlbus_arvalid;
	wire		axi_controlbus_arready;
	wire	[11:0]	axi_controlbus_arid;
	wire	[4:0]	axi_controlbus_araddr;
	wire	[7:0]	axi_controlbus_arlen;
	wire	[2:0]	axi_controlbus_arsize;
	wire	[1:0]	axi_controlbus_arburst;
	wire		axi_controlbus_arlock;
	wire	[3:0]	axi_controlbus_arcache;
	wire	[2:0]	axi_controlbus_arprot;
	wire	[3:0]	axi_controlbus_arqos;
	//
	wire		axi_controlbus_rvalid;
	wire		axi_controlbus_rready;
	wire	[11:0]	axi_controlbus_rid;
	wire	[31:0]	axi_controlbus_rdata;

	wire		axi_controlbus_rlast;

	wire	[1:0]	axi_controlbus_rresp;
	// Bus axil
	//	// AXI-lite slave definitions for bus axil,
	// component controlbus, with prefix axil_controlbus
	//
	// Verilator lint_off UNUSED
	wire		axil_controlbus_awready, axil_controlbus_wready,
			axil_controlbus_arready;
	wire		axil_controlbus_bvalid, axil_controlbus_rvalid;
	wire	[1:0]	axil_controlbus_bresp, axil_controlbus_rresp;
	wire	[31:0]	axil_controlbus_rdata;

	wire		axil_controlbus_awvalid, axil_controlbus_wvalid,
			axil_controlbus_arvalid,
			axil_controlbus_bready, axil_controlbus_rready;
	wire	[4:0]	axil_controlbus_araddr, axil_controlbus_awaddr;
	wire	[2:0]	axil_controlbus_arprot, axil_controlbus_awprot;
	wire	[31:0]	axil_controlbus_wdata;
	wire	[3:0]	axil_controlbus_wstrb;

	// Verilator lint_on  UNUSED

	// Bus axil has no SINGLE slaves
	//

	// Bus axil is all DOUBLE slaves
	//
	//	// AXI-lite slave definitions for bus axil,
	// component board, with prefix axil_board
	//
	// Verilator lint_off UNUSED
	wire		axil_board_awready, axil_board_wready,
			axil_board_arready;
	wire		axil_board_bvalid, axil_board_rvalid;
	wire	[1:0]	axil_board_bresp, axil_board_rresp;
	wire	[31:0]	axil_board_rdata;

	wire		axil_board_awvalid, axil_board_wvalid,
			axil_board_arvalid,
			axil_board_bready, axil_board_rready;
	wire	[4:0]	axil_board_araddr, axil_board_awaddr;
	wire	[2:0]	axil_board_arprot, axil_board_awprot;
	wire	[31:0]	axil_board_wdata;
	wire	[3:0]	axil_board_wstrb;

	// Verilator lint_on  UNUSED
	// Bus aximem

	// Bus aximem has no SINGLE slaves
	//

	// Bus aximem has no DOUBLE slaves
	//
	//	// AXI4 slave definitions for bus aximem,
	// slave hp0, with prefix aximem_hp0
	//
	wire		aximem_hp0_awvalid;
	wire		aximem_hp0_awready;
	wire	[5:0]	aximem_hp0_awid;
	wire	[31:0]	aximem_hp0_awaddr;
	wire	[7:0]	aximem_hp0_awlen;
	wire	[2:0]	aximem_hp0_awsize;
	wire	[1:0]	aximem_hp0_awburst;
	wire		aximem_hp0_awlock;
	wire	[3:0]	aximem_hp0_awcache;
	wire	[2:0]	aximem_hp0_awprot;
	wire	[3:0]	aximem_hp0_awqos;
	//
	wire		aximem_hp0_wvalid;
	wire		aximem_hp0_wready;
	wire	[63:0]	aximem_hp0_wdata;

	wire	[7:0]	aximem_hp0_wstrb;

	wire		aximem_hp0_wlast;

	wire		aximem_hp0_bvalid;
	wire		aximem_hp0_bready;
	wire	[5:0]	aximem_hp0_bid;
	wire	[1:0]	aximem_hp0_bresp;
	wire		aximem_hp0_arvalid;
	wire		aximem_hp0_arready;
	wire	[5:0]	aximem_hp0_arid;
	wire	[31:0]	aximem_hp0_araddr;
	wire	[7:0]	aximem_hp0_arlen;
	wire	[2:0]	aximem_hp0_arsize;
	wire	[1:0]	aximem_hp0_arburst;
	wire		aximem_hp0_arlock;
	wire	[3:0]	aximem_hp0_arcache;
	wire	[2:0]	aximem_hp0_arprot;
	wire	[3:0]	aximem_hp0_arqos;
	//
	wire		aximem_hp0_rvalid;
	wire		aximem_hp0_rready;
	wire	[5:0]	aximem_hp0_rid;
	wire	[63:0]	aximem_hp0_rdata;

	wire		aximem_hp0_rlast;

	wire	[1:0]	aximem_hp0_rresp;

	//
	// Peripheral address decoding
	//
	//
	// BUS-LOGIC for axi
	//
	//
	// Bus axi has only one master (gp0) and one slave (controlbus)
	// connected to it -- skipping the interconnect
	//
	assign	axi_controlbus_awvalid = axi_gp0_awvalid;
	assign	axi_gp0_awready = axi_controlbus_awready;
	assign	axi_controlbus_awid    = axi_gp0_awid;
	assign	axi_controlbus_awaddr  = axi_gp0_awaddr;
	assign	axi_controlbus_awlen   = axi_gp0_awlen;
	assign	axi_controlbus_awsize  = axi_gp0_awsize;
	assign	axi_controlbus_awburst = axi_gp0_awburst;
	assign	axi_controlbus_awlock  = axi_gp0_awlock;
	assign	axi_controlbus_awcache = axi_gp0_awcache;
	assign	axi_controlbus_awprot  = axi_gp0_awprot;
	assign	axi_controlbus_awqos   = axi_gp0_awqos;
	//
	assign	axi_controlbus_wvalid  = axi_gp0_wvalid;
	assign	axi_gp0_wready  = axi_controlbus_wready;
	assign	axi_controlbus_wdata   = axi_gp0_wdata;
	assign	axi_controlbus_wstrb   = axi_gp0_wstrb;
	assign	axi_controlbus_wlast   = axi_gp0_wlast;
	//
	assign	axi_gp0_bvalid  = axi_controlbus_bvalid;
	assign	axi_controlbus_bready  = axi_gp0_bready;
	assign	axi_gp0_bid     = axi_controlbus_bid;
	assign	axi_gp0_bresp   = axi_controlbus_bresp;
	//
	//
	assign	axi_controlbus_arvalid = axi_gp0_arvalid;
	assign	axi_gp0_arready = axi_controlbus_arready;
	assign	axi_controlbus_arid    = axi_gp0_arid;
	assign	axi_controlbus_araddr  = axi_gp0_araddr;
	assign	axi_controlbus_arlen   = axi_gp0_arlen;
	assign	axi_controlbus_arsize  = axi_gp0_arsize;
	assign	axi_controlbus_arburst = axi_gp0_arburst;
	assign	axi_controlbus_arlock  = axi_gp0_arlock;
	assign	axi_controlbus_arcache = axi_gp0_arcache;
	assign	axi_controlbus_arprot  = axi_gp0_arprot;
	assign	axi_controlbus_arqos   = axi_gp0_arqos;
	//
	assign	axi_gp0_rvalid  = axi_controlbus_rvalid;
	assign	axi_controlbus_rready  = axi_gp0_rready;
	assign	axi_gp0_rid     = axi_controlbus_rid;
	assign	axi_gp0_rdata   = axi_controlbus_rdata;
	assign	axi_gp0_rlast   = axi_controlbus_rlast;
	assign	axi_gp0_rresp   = axi_controlbus_rresp;

	//
	// BUS-LOGIC for axil
	//
	//
	// Bus axil has only one master (controlbus) and one slave (board)
	// connected to it -- skipping the interconnect
	//
	assign	axil_board_awvalid = axil_controlbus_awvalid;
	assign	axil_controlbus_awready = axil_board_awready;
	assign	axil_board_awaddr  = axil_controlbus_awaddr;
	assign	axil_board_awprot  = axil_controlbus_awprot;
	//
	assign	axil_board_wvalid = axil_controlbus_wvalid;
	assign	axil_controlbus_wready = axil_board_wready;
	assign	axil_board_wdata  = axil_controlbus_wdata;
	assign	axil_board_wstrb  = axil_controlbus_wstrb;
	//
	assign	axil_controlbus_bvalid  = axil_board_bvalid;
	assign	axil_board_bready  = axil_controlbus_bready;
	assign	axil_controlbus_bresp   = axil_board_bresp;
	//
	assign	axil_board_arvalid = axil_controlbus_arvalid;
	assign	axil_controlbus_arready = axil_board_arready;
	assign	axil_board_araddr  = axil_controlbus_araddr;
	assign	axil_board_arprot  = axil_controlbus_arprot;
	//
	assign	axil_controlbus_rvalid  = axil_board_rvalid;
	assign	axil_board_rready  = axil_controlbus_rready;
	assign	axil_controlbus_rdata   = axil_board_rdata;
	assign	axil_controlbus_rresp   = axil_board_rresp;

	//
	// BUS-LOGIC for aximem
	//
	//
	// The aximem_hp0 bus has no masters assigned to it
	//
	assign	aximem_hp0_awvalid = 1'b0;
	assign	aximem_hp0_awid    = 0;
	assign	aximem_hp0_awaddr  = 0;
	assign	aximem_hp0_awlen   = 8'h00;
	assign	aximem_hp0_awsize  = 3'b000;
	assign	aximem_hp0_awburst = 2'b00;
	assign	aximem_hp0_awlock  = 1'b0;
	assign	aximem_hp0_awcache = 4'h0;
	assign	aximem_hp0_awprot  = 3'h0;
	assign	aximem_hp0_awqos   = 4'h0;
	//
	assign	aximem_hp0_wvalid  = 1'b0;
	assign	aximem_hp0_wdata   = 0;
	assign	aximem_hp0_wstrb   = 0;
	assign	aximem_hp0_wlast   = 1'b1;
	//
	assign	aximem_hp0_bready  = 1'b0;
	//
	//
	assign	aximem_hp0_arvalid = 1'b0;
	assign	aximem_hp0_arid    = 0;
	assign	aximem_hp0_araddr  = 0;
	assign	aximem_hp0_arlen   = 8'h00;
	assign	aximem_hp0_arsize  = 3'b000;
	assign	aximem_hp0_arburst = 2'b00;
	assign	aximem_hp0_arlock  = 1'b0;
	assign	aximem_hp0_arcache = 4'h0;
	assign	aximem_hp0_arprot  = 3'h0;
	assign	aximem_hp0_arqos   = 4'h0;
	//
	assign	aximem_hp0_rready  = 1'b1;

	//
	//
	wire	aximem_hp0_unused;
	assign	aximem_hp0_unused = &{ 1'b0, aximem_hp0_awready, aximem_hp0_wready,
		aximem_hp0_bvalid, aximem_hp0_bid, aximem_hp0_bresp,
		aximem_hp0_arready,
		aximem_hp0_rvalid, aximem_hp0_rid, aximem_hp0_rdata,
			aximem_hp0_rlast, aximem_hp0_rresp
		};
	//
	// Declare the interrupt busses
	//
	// Interrupt busses are defined by anything with a @PIC tag.
	// The @PIC.BUS tag defines the name of the wire bus below,
	// while the @PIC.MAX tag determines the size of the bus width.
	//
	// For your peripheral to be assigned to this bus, it must have an
	// @INT.NAME.WIRE= tag to define the wire name of the interrupt line,
	// and an @INT.NAME.PIC= tag matching the @PIC.BUS tag of the bus
	// your interrupt will be assigned to.  If an @INT.NAME.ID tag also
	// exists, then your interrupt will be assigned to the position given
	// by the ID# in that tag.
	//


	//
	//
	// Now we turn to defining all of the parts and pieces of what
	// each of the various peripherals does, and what logic it needs.
	//
	// This information comes from the @MAIN.INSERT and @MAIN.ALT tags.
	// If an @ACCESS tag is available, an ifdef is created to handle
	// having the access and not.  If the @ACCESS tag is `defined above
	// then the @MAIN.INSERT code is executed.  If not, the @MAIN.ALT
	// code is exeucted, together with any other cleanup settings that
	// might need to take place--such as returning zeros to the bus,
	// or making sure all of the various interrupt wires are set to
	// zero if the component is not included.
	//
	//
	// Connect the PS master port (AXI3 out of the Zynq) to our internal
	// bus representation
	assign	axi_gp0_awvalid = i_GP0_AWVALID;
	assign	o_GP0_AWREADY = axi_gp0_awready;
	assign	axi_gp0_awid    = i_GP0_AWID;
	assign	axi_gp0_awaddr  = i_GP0_AWADDR[5-1:0];
	assign	axi_gp0_awlen   = i_GP0_AWLEN;
	assign	axi_gp0_awsize  = i_GP0_AWSIZE;
	assign	axi_gp0_awburst = i_GP0_AWBURST;
	assign	axi_gp0_awlock  = i_GP0_AWLOCK;
	assign	axi_gp0_awcache = i_GP0_AWCACHE;
	assign	axi_gp0_awprot  = i_GP0_AWPROT;
	assign	axi_gp0_awqos   = i_GP0_AWQOS;
		//
	assign	axi_gp0_wvalid = i_GP0_WVALID;
	assign	o_GP0_WREADY = axi_gp0_wready;
		// M_AXI_GP0_WID,
	assign	axi_gp0_wdata  = i_GP0_WDATA;
	assign	axi_gp0_wstrb  = i_GP0_WSTRB;
	assign	axi_gp0_wlast  = i_GP0_WLAST;
		//
	assign	o_GP0_BVALID = axi_gp0_bvalid;
	assign	axi_gp0_bready = i_GP0_BREADY;
	assign	o_GP0_BID    = axi_gp0_bid;
	assign	o_GP0_BRESP  = axi_gp0_bresp;
		//
	assign	axi_gp0_arvalid = i_GP0_ARVALID;
	assign	o_GP0_ARREADY = axi_gp0_arready;
	assign	axi_gp0_arid    = i_GP0_ARID;
	assign	axi_gp0_araddr  = i_GP0_ARADDR[5-1:0];
	assign	axi_gp0_arsize  = i_GP0_ARSIZE;
	assign	axi_gp0_arburst = i_GP0_ARBURST;
	assign	axi_gp0_arlen   = i_GP0_ARLEN;
	assign	axi_gp0_arlock  = i_GP0_ARLOCK;
	assign	axi_gp0_arcache = i_GP0_ARCACHE;
	assign	axi_gp0_arprot  = i_GP0_ARPROT;
	assign	axi_gp0_arqos   = i_GP0_ARQOS;
		//
	assign	o_GP0_RVALID = axi_gp0_rvalid;
	assign	axi_gp0_rready = i_GP0_RREADY;
	assign	o_GP0_RID    = axi_gp0_rid;
	assign	o_GP0_RDATA  = axi_gp0_rdata;
	assign	o_GP0_RLAST  = axi_gp0_rlast;
	assign	o_GP0_RRESP  = axi_gp0_rresp;

	axi2axilite #(
		.C_AXI_ADDR_WIDTH(5),
		.C_AXI_DATA_WIDTH(32),
		.C_AXI_ID_WIDTH(12)
	) controlbusi (
		.S_AXI_ACLK(i_clk),
		.S_AXI_ARESETN(!i_reset),
		//
		//
		.S_AXI_AWVALID(axi_controlbus_awvalid),
		.S_AXI_AWREADY(axi_controlbus_awready),
		.S_AXI_AWID(   axi_controlbus_awid),
		.S_AXI_AWADDR( axi_controlbus_awaddr[5-1:0]),
		.S_AXI_AWLEN(  axi_controlbus_awlen),
		.S_AXI_AWSIZE( axi_controlbus_awsize),
		.S_AXI_AWBURST(axi_controlbus_awburst),
		.S_AXI_AWLOCK( axi_controlbus_awlock),
		.S_AXI_AWCACHE(axi_controlbus_awcache),
		.S_AXI_AWPROT( axi_controlbus_awprot),
		.S_AXI_AWQOS(  axi_controlbus_awqos),
//
		.S_AXI_WVALID(axi_controlbus_wvalid),
		.S_AXI_WREADY(axi_controlbus_wready),
		.S_AXI_WDATA( axi_controlbus_wdata),
		.S_AXI_WSTRB( axi_controlbus_wstrb),
		.S_AXI_WLAST( axi_controlbus_wlast),
//
		.S_AXI_BVALID(axi_controlbus_bvalid),
		.S_AXI_BREADY(axi_controlbus_bready),
		.S_AXI_BID(   axi_controlbus_bid),
		.S_AXI_BRESP( axi_controlbus_bresp),
		// Read connections
		.S_AXI_ARVALID(axi_controlbus_arvalid),
		.S_AXI_ARREADY(axi_controlbus_arready),
		.S_AXI_ARID(   axi_controlbus_arid),
		.S_AXI_ARADDR( axi_controlbus_araddr[5-1:0]),
		.S_AXI_ARLEN(  axi_controlbus_arlen),
		.S_AXI_ARSIZE( axi_controlbus_arsize),
		.S_AXI_ARBURST(axi_controlbus_arburst),
		.S_AXI_ARLOCK( axi_controlbus_arlock),
		.S_AXI_ARCACHE(axi_controlbus_arcache),
		.S_AXI_ARPROT( axi_controlbus_arprot),
		.S_AXI_ARQOS(  axi_controlbus_arqos),
//
		.S_AXI_RVALID(axi_controlbus_rvalid),
		.S_AXI_RREADY(axi_controlbus_rready),
		.S_AXI_RID(   axi_controlbus_rid),
		.S_AXI_RDATA( axi_controlbus_rdata),
		.S_AXI_RLAST( axi_controlbus_rlast),
		.S_AXI_RRESP( axi_controlbus_rresp),
		//
		//
		.M_AXI_AWVALID(axil_controlbus_awvalid),
		.M_AXI_AWREADY(axil_controlbus_awready),
		.M_AXI_AWADDR( axil_controlbus_awaddr[5-1:0]),
		.M_AXI_AWPROT( axil_controlbus_awprot),
//
		.M_AXI_WVALID(axil_controlbus_wvalid),
		.M_AXI_WREADY(axil_controlbus_wready),
		.M_AXI_WDATA( axil_controlbus_wdata),
		.M_AXI_WSTRB( axil_controlbus_wstrb),
//
		.M_AXI_BVALID(axil_controlbus_bvalid),
		.M_AXI_BREADY(axil_controlbus_bready),
		.M_AXI_BRESP( axil_controlbus_bresp),
		// Read connections
		.M_AXI_ARVALID(axil_controlbus_arvalid),
		.M_AXI_ARREADY(axil_controlbus_arready),
		.M_AXI_ARADDR( axil_controlbus_araddr[5-1:0]),
		.M_AXI_ARPROT( axil_controlbus_arprot),
//
		.M_AXI_RVALID(axil_controlbus_rvalid),
		.M_AXI_RREADY(axil_controlbus_rready),
		.M_AXI_RDATA( axil_controlbus_rdata),
		.M_AXI_RRESP( axil_controlbus_rresp)
	);
	//
	// Connect the PS master port (AXI3 out of the Zynq) to our internal
	// bus representation
	assign	o_HP0_AWVALID = aximem_hp0_awvalid;
	assign	aximem_hp0_awready = i_HP0_AWREADY;
	assign	o_HP0_AWID   = aximem_hp0_awid;
	assign	o_HP0_AWADDR = aximem_hp0_awaddr;
	assign	o_HP0_AWLEN  = aximem_hp0_awlen;
	assign	o_HP0_AWSIZE = aximem_hp0_awsize;
	assign	o_HP0_AWBURST= aximem_hp0_awburst;
	assign	o_HP0_AWLOCK = aximem_hp0_awlock;
	assign	o_HP0_AWCACHE= aximem_hp0_awcache;
	assign	o_HP0_AWPROT = aximem_hp0_awprot;
	assign	o_HP0_AWQOS  = aximem_hp0_awqos;
		//
	assign	o_HP0_WVALID = aximem_hp0_wvalid;
	assign	aximem_hp0_wready = i_HP0_WREADY;
		// M_AXI_HP0_WID,
	assign	o_HP0_WDATA = aximem_hp0_wdata;
	assign	o_HP0_WSTRB = aximem_hp0_wstrb;
	assign	o_HP0_WLAST = aximem_hp0_wlast;
		//
	assign	aximem_hp0_bvalid = i_HP0_BVALID;
	assign	o_HP0_BREADY = aximem_hp0_bready;
	assign	aximem_hp0_bid    = i_HP0_BID;
	assign	aximem_hp0_bresp  = i_HP0_BRESP;
		//
	assign	o_HP0_ARVALID = aximem_hp0_arvalid;
	assign	aximem_hp0_arready = i_HP0_ARREADY;
	assign	o_HP0_ARID   = aximem_hp0_arid;
	assign	o_HP0_ARADDR = aximem_hp0_araddr;
	assign	o_HP0_ARLEN  = aximem_hp0_arlen;
	assign	o_HP0_ARSIZE = aximem_hp0_arsize;
	assign	o_HP0_ARBURST= aximem_hp0_arburst;
	assign	o_HP0_ARLOCK = aximem_hp0_arlock;
	assign	o_HP0_ARCACHE= aximem_hp0_arcache;
	assign	o_HP0_ARPROT = aximem_hp0_arprot;
	assign	o_HP0_ARQOS  = aximem_hp0_arqos;
		//
	assign	aximem_hp0_rvalid = i_HP0_RVALID;
	assign	o_HP0_RREADY = aximem_hp0_rready;
	assign	aximem_hp0_rid    = i_HP0_RID;
	assign	aximem_hp0_rdata  = i_HP0_RDATA;
	assign	aximem_hp0_rlast  = i_HP0_RLAST;
	assign	aximem_hp0_rresp  = i_HP0_RRESP;

	assign	o_HP0_WRISSUECAP1_EN = 1'b1;
	assign	o_HP0_RDISSUECAP1_EN = 1'b1;

	axilboard // #()
	boardi (
		.S_AXI_ACLK(i_clk),
		.S_AXI_ARESETN(!i_reset),
		//
		//
		.S_AXI_AWVALID(axil_board_awvalid),
		.S_AXI_AWREADY(axil_board_awready),
		.S_AXI_AWADDR( axil_board_awaddr[5-1:0]),
		.S_AXI_AWPROT( axil_board_awprot),
//
		.S_AXI_WVALID(axil_board_wvalid),
		.S_AXI_WREADY(axil_board_wready),
		.S_AXI_WDATA( axil_board_wdata),
		.S_AXI_WSTRB( axil_board_wstrb),
//
		.S_AXI_BVALID(axil_board_bvalid),
		.S_AXI_BREADY(axil_board_bready),
		.S_AXI_BRESP( axil_board_bresp),
		// Read connections
		.S_AXI_ARVALID(axil_board_arvalid),
		.S_AXI_ARREADY(axil_board_arready),
		.S_AXI_ARADDR( axil_board_araddr[5-1:0]),
		.S_AXI_ARPROT( axil_board_arprot),
//
		.S_AXI_RVALID(axil_board_rvalid),
		.S_AXI_RREADY(axil_board_rready),
		.S_AXI_RDATA( axil_board_rdata),
		.S_AXI_RRESP( axil_board_rresp),
		//
		.i_sw(i_sw), .i_btn(i_btn), .o_led(o_led),
		.o_led_red(o_redled), .o_led_grn(o_grnled),
		  .o_led_blu(o_bluled)
	);



endmodule // main.v
